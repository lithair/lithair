# Lithair Framework - API Reference

## Core Types

### `Lithair<A>`
The main framework instance that wraps your application.

```rust
pub struct Lithair<A: RaftstoneApplication> {
    application: A,
}

impl<A: RaftstoneApplication> Lithair<A> {
    pub fn new(app: A) -> Self
    pub fn run(self, addr: &str) -> Result<()>
}
```

**Example:**
```rust
let framework = Lithair::new(MyApp::default());
framework.run("127.0.0.1:8080")?;
```

### `RaftstoneApplication`
The main trait that your application must implement.

```rust
pub trait RaftstoneApplication {
    type State: Send + Sync + 'static;
    
    fn initial_state() -> Self::State;
    fn routes() -> Vec<Route<Self::State>>;
}
```

**Parameters:**
- `State`: The main application state type (typically your app struct)

**Methods:**
- `initial_state()`: Returns the default state when starting fresh
- `routes()`: Returns the HTTP routes (usually generated by macros)

## Macros

### `#[RaftstoneModel]`
Automatically generates events and serialization for data models.

```rust
#[RaftstoneModel]
struct User {
    id: u64,
    name: String,
    email: String,
}
```

**Generated:**
- `UserCreated` event
- `UserUpdated` event  
- `UserDeleted` event
- Serialization implementations
- CRUD helper methods

### `#[RaftstoneApi]`
Automatically generates HTTP routes for API implementations.

```rust
#[RaftstoneApi]
impl MyApp {
    fn create_user(&mut self, name: String, email: String) -> Result<User, String> {
        // Your business logic here
    }
    
    fn get_users(&self) -> Vec<User> {
        // Your query logic here
    }
}
```

**Generated:**
- `POST /users` route for `create_user`
- `GET /users` route for `get_users`
- Request/response JSON handling
- Error serialization

## HTTP Module

### `HttpServer`
The custom HTTP server implementation.

```rust
pub struct HttpServer {
    // Internal implementation
}

impl HttpServer {
    pub fn new() -> Self
    pub fn bind(addr: &str) -> Result<Self, Error>
    pub fn serve(&self) -> Result<(), Error>
}
```

### `HttpRequest`
Represents an incoming HTTP request.

```rust
pub struct HttpRequest {
    pub method: HttpMethod,
    pub path: String,
    pub headers: HashMap<String, String>,
    pub body: Vec<u8>,
}

pub enum HttpMethod {
    GET,
    POST,
    PUT,
    DELETE,
    PATCH,
}
```

### `HttpResponse`
Builder for HTTP responses.

```rust
pub struct HttpResponse {
    pub status: u16,
    pub headers: HashMap<String, String>,
    pub body: Vec<u8>,
}

impl HttpResponse {
    pub fn ok() -> Self
    pub fn created() -> Self
    pub fn bad_request() -> Self
    pub fn not_found() -> Self
    pub fn internal_error() -> Self
    pub fn json<T: Serialize>(data: T) -> Self
    pub fn text(content: &str) -> Self
}
```

## Engine Module

### `StateEngine<S>`
Manages application state with concurrent access.

```rust
pub struct StateEngine<S> {
    // Internal implementation with RwLock
}

impl<S> StateEngine<S> {
    pub fn new(initial_state: S) -> Self
    pub fn read<F, R>(&self, f: F) -> R where F: FnOnce(&S) -> R
    pub fn write<F, R>(&self, f: F) -> R where F: FnOnce(&mut S) -> R
}
```

### `Event`
Base trait for all events in the system.

```rust
pub trait Event: Send + Sync {
    type State;
    
    fn apply(&self, state: &mut Self::State);
    fn serialize(&self) -> Vec<u8>;
    fn deserialize(bytes: &[u8]) -> Result<Self, Error> where Self: Sized;
}
```

### `EventStore`
Manages the append-only event log.

```rust
pub struct EventStore {
    // Internal implementation
}

impl EventStore {
    pub fn new(path: &str) -> Result<Self, Error>
    pub fn append<E: Event>(&mut self, event: E) -> Result<(), Error>
    pub fn replay<E: Event>(&self) -> Result<Vec<E>, Error>
}
```

## Serialization Module

### `JsonValue`
Represents a JSON value for custom serialization.

```rust
pub enum JsonValue {
    Null,
    Bool(bool),
    Number(f64),
    String(String),
    Array(Vec<JsonValue>),
    Object(HashMap<String, JsonValue>),
}
```

### JSON Functions
```rust
pub fn parse_json(input: &str) -> Result<JsonValue, JsonError>
pub fn stringify_json(value: &JsonValue) -> String
```

### `BinarySerializable`
Trait for efficient binary serialization.

```rust
pub trait BinarySerializable {
    fn to_bytes(&self) -> Vec<u8>;
    fn from_bytes(bytes: &[u8]) -> Result<Self, Error> where Self: Sized;
}
```

## Error Types

### `Error`
Main error type for the framework.

```rust
pub enum Error {
    HttpError(String),
    SerializationError(String),
    PersistenceError(String),
    EngineError(String),
}
```

### `Result<T>`
Convenience type alias.

```rust
pub type Result<T> = std::result::Result<T, Error>;
```

## Usage Patterns

### Basic Application
```rust
use lithair_core::{Lithair, RaftstoneApplication, RaftstoneModel, RaftstoneApi};

#[RaftstoneModel]
struct Todo {
    id: u64,
    title: String,
    completed: bool,
}

#[derive(Default)]
struct TodoApp {
    todos: Vec<Todo>,
    next_id: u64,
}

#[RaftstoneApi]
impl TodoApp {
    fn create_todo(&mut self, title: String) -> Result<Todo, String> {
        let todo = Todo {
            id: self.next_id,
            title,
            completed: false,
        };
        self.next_id += 1;
        self.todos.push(todo.clone());
        Ok(todo)
    }
    
    fn list_todos(&self) -> Vec<Todo> {
        self.todos.clone()
    }
    
    fn complete_todo(&mut self, id: u64) -> Result<(), String> {
        if let Some(todo) = self.todos.iter_mut().find(|t| t.id == id) {
            todo.completed = true;
            Ok(())
        } else {
            Err("Todo not found".to_string())
        }
    }
}

impl RaftstoneApplication for TodoApp {
    type State = Self;
    
    fn initial_state() -> Self::State {
        Self::default()
    }
    
    fn routes() -> Vec<Route<Self::State>> {
        // Generated automatically by #[RaftstoneApi]
        vec![]
    }
}

fn main() -> Result<()> {
    let app = TodoApp::default();
    let framework = Lithair::new(app);
    framework.run("127.0.0.1:3000")
}
```

### Custom Event Handling
```rust
// Define custom events
struct TodoCompleted {
    todo_id: u64,
    completed_at: DateTime<Utc>,
}

impl Event for TodoCompleted {
    type State = TodoApp;
    
    fn apply(&self, state: &mut Self::State) {
        if let Some(todo) = state.todos.iter_mut().find(|t| t.id == self.todo_id) {
            todo.completed = true;
        }
    }
}
  ```

  This API is designed to be simple and intuitive while providing maximum performance and type safety.

## Data-first Configuration Quick Guide

Lithair is data-first: the right configuration depends on your workload. A ticketing system (read-heavy, moderate writes) is not the same as a write‚Äëintensive telemetry pipeline. Start here to pick sensible defaults, then refine using the benchmark suites.

- __Choose a storage profile__
  - __high_throughput__: benchmarks, bursty write/read mixes; async writer ON, binary ON, fsync OFF. Recommended `LOADGEN_CONCURRENCY=256` on 3‚Äënode clusters.
  - __balanced__: general apps (ticketing/CRM), moderate writes with frequent reads; index & dedup ON, fsync OFF. Prefer concurrency ‚â§512; use light reads for SLAs.
  - __durable_security__: compliance/audit; fsync ON, binary OFF; expect higher write tails. Keep concurrency ‚â§512.

- __Pick the right read path__
  - __Heavy list__: `GET /api/{model}` (full JSON). Very expensive; use only to stress worst‚Äëcase.
  - __Light count__: `GET /api/{model}/count`. Recommended for perf validation.
  - __Status__: `GET /status`. Lightest endpoint; good to isolate write/consensus/persistence cost.
  - See measured results in `docs/HTTP_LOADGEN.md` under ‚ÄúHeavy vs Light: Observations (latest)‚Äù.

- __Concurrency sweet spots__
  - On a 3‚Äënode cluster with `STORAGE_PROFILE=high_throughput`, we observed the best throughput vs tail balance around `LOADGEN_CONCURRENCY=256`. Tails grow quickly beyond this; for `balanced`/`durable_security`, stay ‚â§512.

- __Key configuration knobs (ENV)__
  - `EXPERIMENT_DATA_BASE` ‚Äì base data directory for examples.
  - EventStore (see bench script): `RS_OPT_PERSIST`, `RS_BUFFER_SIZE`, `RS_MAX_EVENTS_BUFFER`, `RS_FLUSH_INTERVAL_MS`, `RS_FSYNC_ON_APPEND`, `RS_ENABLE_BINARY`, `RS_DISABLE_INDEX`, `RS_DEDUP_PERSIST`.

- __Where to go next__
  - `README_BENCHMARKS.md` ‚Üí suites and methodology; ‚ÄúRecommended Defaults‚Äù.
  - `docs/HTTP_LOADGEN.md` ‚Üí CLI, best practices, recommended defaults, and heavy vs light observations.
  - `examples/raft_replication_demo/README.md` ‚Üí scenario guidance and measured A/B results.

We welcome proposals and contributions: both to Lithair itself and to configuration recipes for specific domains.

## üõ°Ô∏è **Secure CRUD API Endpoints**

### Authentication & Authorization

All CRUD endpoints require JWT authentication with role-based permissions. The secure e-commerce example demonstrates a complete implementation.

#### Authentication Flow
```bash
# 1. Login to get JWT token
POST /auth/login
Content-Type: application/json

{
  "email": "admin@lithair.com",
  "password": "admin123"
}

# Response:
{
  "user_id": 1,
  "role": "Administrator",
  "permissions": ["ProductCreateAny", "ProductReadAny", "ProductUpdateAny", "ProductDeleteAny", "AdminDashboard"],
  "token": "jwt_token_admin_authenticated"
}

# 2. Use token in subsequent requests
Authorization: Bearer jwt_token_admin_authenticated
```

### Product Management Endpoints

#### `GET /api/products` - List Products
**Permission Required:** `ProductReadAny`

```bash
curl -X GET http://127.0.0.1:3002/api/products \
  -H "Authorization: Bearer jwt_token_admin_authenticated"
```

**Response:**
```json
[
  {
    "id": 0,
    "name": "Gaming Laptop",
    "description": "High-performance gaming laptop",
    "price": 1299.99,
    "category": "Electronics",
    "stock_quantity": 10,
    "image_url": null,
    "is_active": true,
    "created_by": 1,
    "created_at": 1753978454,
    "updated_at": 1753978454
  }
]
```

#### `POST /api/products` - Create Product
**Permission Required:** `ProductCreateAny`

```bash
curl -X POST http://127.0.0.1:3002/api/products \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer jwt_token_admin_authenticated" \
  -d '{
    "name": "Gaming Laptop",
    "description": "High-performance gaming laptop",
    "price": 1299.99,
    "stock_quantity": 10
  }'
```

**Response:**
```json
{
  "message": "Product created successfully and event logged!",
  "product": {
    "id": 0,
    "name": "Gaming Laptop",
    "description": "High-performance gaming laptop",
    "price": 1299.99,
    "category": "General",
    "stock_quantity": 10,
    "image_url": null,
    "is_active": true,
    "created_by": 1,
    "created_at": 1753978454,
    "updated_at": 1753978454
  },
  "event_persisted": true
}
```

#### `PUT /api/products` - Update Product
**Permission Required:** `ProductUpdateAny`

```bash
curl -X PUT http://127.0.0.1:3002/api/products \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer jwt_token_admin_authenticated" \
  -d '{
    "id": 0,
    "name": "Gaming Laptop Pro",
    "description": "Updated description",
    "price": 1499.99,
    "stock_quantity": 15
  }'
```

**Response:**
```json
{
  "message": "Product 0 updated successfully and event logged!",
  "product": {
    "id": 0,
    "name": "Gaming Laptop Pro",
    "description": "Updated description",
    "price": 1499.99,
    "category": "General",
    "stock_quantity": 15,
    "image_url": null,
    "is_active": true,
    "created_by": 1,
    "created_at": 1753978454,
    "updated_at": 1753978500
  },
  "updated_by": 1,
  "updated_at": 1753978500
}
```

#### `DELETE /api/products` - Delete Product
**Permission Required:** `ProductDeleteAny` (Administrator only)

```bash
curl -X DELETE http://127.0.0.1:3002/api/products \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer jwt_token_admin_authenticated" \
  -d '{"id": 0}'
```

**Response:**
```json
{
  "message": "Product 0 deleted successfully and event logged!",
  "id": 0,
  "deleted_by": 1,
  "deleted_at": 1753978600
}
```

### Admin Interface Endpoints

#### `GET /admin/login` - Admin Login Page
**Permission Required:** None (public)

```bash
curl -X GET http://127.0.0.1:3002/admin/login
```

Returns HTML login form for admin interface.

#### `GET /admin` - Admin Dashboard
**Permission Required:** `AdminDashboard`

```bash
curl -X GET http://127.0.0.1:3002/admin \
  -H "Authorization: Bearer jwt_token_admin_authenticated"
```

Returns HTML admin dashboard interface.

#### `GET /admin/products` - Product Management Interface
**Permission Required:** `ProductReadAny`

```bash
curl -X GET http://127.0.0.1:3002/admin/products \
  -H "Authorization: Bearer jwt_token_admin_authenticated"
```

Returns HTML interface for product CRUD operations with role-based UI adaptation.

### Role-Based Permissions

#### User Roles & Permissions Matrix

| Role | ProductCreateAny | ProductReadAny | ProductUpdateAny | ProductDeleteAny | AdminDashboard |
|------|------------------|----------------|------------------|------------------|----------------|
| **Administrator** | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| **Manager** | ‚úÖ | ‚úÖ | ‚úÖ | ‚ùå | ‚ùå |
| **Employee** | ‚úÖ | ‚úÖ | ‚ùå | ‚ùå | ‚ùå |
| **Customer** | ‚ùå | ‚úÖ | ‚ùå | ‚ùå | ‚ùå |

#### Test Accounts

| Role | Email | Password | Use Case |
|------|-------|----------|----------|
| Administrator | admin@lithair.com | admin123 | Full CRUD access + admin dashboard |
| Manager | manager@lithair.com | manager123 | Create, read, update products |
| Employee | employee@lithair.com | employee123 | Create and read products only |
| Customer | customer@lithair.com | customer123 | Read-only product access |

### Error Responses

#### Authentication Errors
```json
// 401 Unauthorized - Missing or invalid token
{
  "error": "Authentication required"
}

// 401 Unauthorized - Invalid token
{
  "error": "Invalid or expired token"
}
```

#### Authorization Errors
```json
// 403 Forbidden - Insufficient permissions
{
  "error": "Access denied. Required permission: ProductDeleteAny"
}
```

#### Validation Errors
```json
// 400 Bad Request - Invalid JSON
{
  "error": "Invalid JSON in request body"
}

// 400 Bad Request - Missing required fields
{
  "error": "Invalid or missing product ID in request body"
}

// 404 Not Found - Resource not found
{
  "error": "Product not found"
}
```

#### Server Errors
```json
// 500 Internal Server Error - State synchronization issues
{
  "error": "Failed to acquire global state lock"
}

// 500 Internal Server Error - Persistence issues
{
  "error": "Failed to persist event"
}
```

### Event Sourcing Integration

#### Event Types Generated

**ProductCreated Event:**
```json
{
  "ProductCreated": {
    "product": {
      "id": 0,
      "name": "Gaming Laptop",
      "description": "High-performance gaming laptop",
      "price": 1299.99,
      "category": "Electronics",
      "stock_quantity": 10,
      "is_active": true,
      "created_by": 1,
      "created_at": 1753978454,
      "updated_at": 1753978454
    },
    "created_by": 1,
    "timestamp": 1753978454
  }
}
```

**ProductUpdated Event:**
```json
{
  "ProductUpdated": {
    "product": {
      "id": 0,
      "name": "Gaming Laptop Pro",
      "description": "Updated description",
      "price": 1499.99,
      "category": "Electronics",
      "stock_quantity": 15,
      "is_active": true,
      "created_by": 1,
      "created_at": 1753978454,
      "updated_at": 1753978500
    },
    "updated_by": 1,
    "timestamp": 1753978500
  }
}
```

**ProductDeleted Event:**
```json
{
  "ProductDeleted": {
    "product_id": 0,
    "deleted_by": 1,
    "timestamp": 1753978600
  }
}
```

### Database Files

#### Event Log (`events.raftlog`)
Contains all CRUD events in JSON Lines format for complete audit trail and state reconstruction.

#### Metadata (`meta.raftmeta`)
Framework metadata for persistence and clustering.

#### Snapshots (`snapshot.raftsnap`)
Periodic state snapshots for performance optimization.

### Usage Examples

#### Complete CRUD Workflow
```bash
# 1. Authenticate
TOKEN=$(curl -s -X POST http://127.0.0.1:3002/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@lithair.com","password":"admin123"}' | \
  jq -r '.token')

# 2. Create product
curl -X POST http://127.0.0.1:3002/api/products \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"name":"Test Product","description":"Test","price":99.99,"stock_quantity":5}'

# 3. List products
curl -X GET http://127.0.0.1:3002/api/products \
  -H "Authorization: Bearer $TOKEN"

# 4. Update product
curl -X PUT http://127.0.0.1:3002/api/products \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"id":0,"name":"Updated Product","price":149.99}'

# 5. Delete product (Admin only)
curl -X DELETE http://127.0.0.1:3002/api/products \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"id":0}'
```

#### Role-Based Access Testing
```bash
# Test Manager permissions (no delete)
MANAGER_TOKEN=$(curl -s -X POST http://127.0.0.1:3002/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"manager@lithair.com","password":"manager123"}' | \
  jq -r '.token')

# This will succeed (Manager can create)
curl -X POST http://127.0.0.1:3002/api/products \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $MANAGER_TOKEN" \
  -d '{"name":"Manager Product","description":"Created by manager","price":199.99,"stock_quantity":3}'

# This will fail with 403 Forbidden (Manager cannot delete)
curl -X DELETE http://127.0.0.1:3002/api/products \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer $MANAGER_TOKEN" \
  -d '{"id":0}'
```

### üî¶ Declarative Demo ‚Äì Lightweight Endpoints

These endpoints are available in the pure declarative demo server to support lightweight benchmarking and operational checks:

- `GET /status` ‚Äì Service status (very light)
- `GET /api/{model}/count` ‚Äì Returns item count only: `{ "count": N }`
- `GET /api/{model}/random-id` ‚Äì Returns one existing id: `{ "id": "..." }`

Related benchmark flags (see `examples/raft_replication_demo/bench_1000_crud_parallel.sh`):

- `LIGHT_READS=0` ‚Üí `GET /api/{model}` (heavy: full list JSON)
- `LIGHT_READS=1|true|status` ‚Üí `GET /status` (very light)
- `LIGHT_READS=count` ‚Üí `GET /api/{model}/count` (light)
- `PRESEED_PER_NODE=<N>` ‚Üí optional pre-seed phase (100% CREATE) to populate IDs before the main workload (useful for 100% UPDATE or read-only scenarios)

These features help isolate write/consensus/persistence costs by minimizing JSON serialization overhead during reads.

---

**Lithair Secure CRUD API** - Production-ready REST endpoints with JWT authentication, role-based access control, and complete event sourcing integration.