//! Lithair RBAC + SSO Demo
//!
//! This example demonstrates Lithair's declarative approach to:
//! - Role-Based Access Control (RBAC)
//! - Multi-provider Single Sign-On (SSO)
//! - Field-level permissions
//! - Custom middleware
//!
//! Run with: cargo run -- --port 8080

use anyhow::Result;
use clap::Parser;
use lithair_core::http::declarative_server::DeclarativeServer;
use lithair_macros::DeclarativeModel;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use uuid::Uuid;

// Note: This is a DEMONSTRATION of the declarative syntax.
// The actual #[derive(DeclarativeModel)], #[permission], #[idp], etc.
// macros would be implemented in lithair-macros.
// For now, we show the INTENDED syntax and simulate the behavior.

/// CLI Arguments
#[derive(Parser, Debug)]
#[command(name = "rbac_sso_demo")]
#[command(about = "Lithair RBAC + SSO Demo", long_about = None)]
struct Args {
    /// Port to listen on
    #[arg(short, long, default_value = "8080")]
    port: u16,

    /// Host to bind to
    #[arg(long, default_value = "127.0.0.1")]
    host: String,
}

// ============================================================================
// DECLARATIVE PERMISSIONS (Simulated)
// ============================================================================

/// Product permissions
/// In the real implementation, this would be:
/// #[derive(Permission)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ProductPermission {
    ProductRead,
    ProductWrite,
    ProductDelete,
    StockRead,
    StockWrite,
}

/// Admin permissions
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum AdminPermission {
    AdminDashboard,
    UserManagement,
}

// ============================================================================
// DECLARATIVE ROLES WITH REAL MACROS
// ============================================================================

/// User roles with associated permissions
///
/// The #[derive(RbacRole)] macro automatically generates the `has_permission` method
/// based on the #[permissions(...)] attributes on each variant.
///
/// This is TRUE declarative RBAC - no manual implementation needed!
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, lithair_macros::RbacRole)]
#[permission_type(ProductPermission)]
pub enum UserRole {
    /// Public access (no authentication required)
    #[allow(dead_code)]
    Public,

    /// Customer - can view products
    #[permissions(ProductRead)]
    Customer,

    /// Employee - can view and create products
    #[permissions(ProductRead, ProductWrite)]
    Employee,

    /// Stock Manager - can manage inventory
    #[permissions(ProductRead, StockRead, StockWrite)]
    StockManager,

    /// Product Manager - can manage products
    #[permissions(ProductRead, ProductWrite, StockRead)]
    ProductManager,

    /// Administrator - full access
    #[permissions(all)]
    Administrator,
}

// ‚úÖ NO MANUAL IMPLEMENTATION NEEDED!
// The has_permission() method is automatically generated by the macro!

// ============================================================================
// DECLARATIVE IDENTITY PROVIDERS (Simulated)
// ============================================================================

/// Identity providers for SSO
/// In the real implementation, this would be:
/// #[derive(IdentityProvider)]
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum AuthProvider {
    /// Google OAuth
    /// #[idp(
    ///     provider = "google",
    ///     client_id = env("GOOGLE_CLIENT_ID"),
    ///     client_secret = env("GOOGLE_CLIENT_SECRET"),
    ///     redirect_uri = "/auth/google/callback",
    ///     scopes = ["email", "profile"]
    /// )]
    Google,

    /// GitHub OAuth
    /// #[idp(
    ///     provider = "github",
    ///     client_id = env("GITHUB_CLIENT_ID"),
    ///     client_secret = env("GITHUB_CLIENT_SECRET"),
    ///     redirect_uri = "/auth/github/callback",
    ///     scopes = ["user:email"]
    /// )]
    GitHub,

    /// Microsoft OAuth (Azure AD)
    /// #[idp(
    ///     provider = "microsoft",
    ///     tenant_id = env("MICROSOFT_TENANT_ID"),
    ///     client_id = env("MICROSOFT_CLIENT_ID"),
    ///     client_secret = env("MICROSOFT_CLIENT_SECRET"),
    ///     redirect_uri = "/auth/microsoft/callback"
    /// )]
    Microsoft,

    /// Local JWT authentication
    /// #[idp(provider = "jwt")]
    LocalJWT,
}

// ============================================================================
// DECLARATIVE MODELS (Simulated)
// ============================================================================

fn generate_uuid() -> Uuid {
    Uuid::new_v4()
}

/// Product model with field-level permissions
/// This demonstrates the DECLARATIVE RBAC syntax
///
/// In the real implementation, the #[sso] attribute would be implemented
/// For now, we show the intended syntax in comments
#[derive(Debug, Clone, Serialize, Deserialize, DeclarativeModel)]
#[rbac(
    enabled = true,
    roles = "Customer,Employee,StockManager,ProductManager,Administrator",
    default_role = "Customer"
)]
// #[sso(
//     providers = "google,github,microsoft,jwt",
//     google_client_id = env("GOOGLE_CLIENT_ID"),
//     github_client_id = env("GITHUB_CLIENT_ID"),
//     microsoft_tenant_id = env("MICROSOFT_TENANT_ID")
// )]
pub struct Product {
    /// Product ID - visible to everyone
    #[db(primary_key, indexed)]
    #[lifecycle(immutable)]
    #[http(expose)]
    #[permission(read = "Public")]
    #[serde(default = "generate_uuid")]
    pub id: Uuid,

    /// Product name - public read, manager write
    #[db(indexed)]
    #[http(expose)]
    #[permission(read = "Public", write = "ProductManager")]
    pub name: String,

    /// Product description - public read, manager write
    #[http(expose)]
    #[permission(read = "Public", write = "ProductManager")]
    pub description: String,

    /// Product price - public read, manager write
    #[http(expose)]
    #[permission(read = "Public", write = "ProductManager")]
    pub price: f64,

    /// Stock quantity - restricted to stock managers
    #[http(expose)]
    #[permission(read = "StockManager", write = "StockManager")]
    pub stock: i32,

    /// Internal cost - admin only
    #[http(expose)]
    #[permission(read = "Administrator", write = "Administrator")]
    pub cost: f64,
}

impl Product {
    /// Filter fields based on user role
    pub fn filter_for_role(&self, role: &UserRole) -> serde_json::Value {
        use serde_json::json;

        let mut product = json!({
            "id": self.id,
            "name": &self.name,
            "description": &self.description,
            "price": self.price,
        });

        // Add stock if user has StockRead permission
        if role.has_permission(ProductPermission::StockRead) {
            product["stock"] = json!(self.stock);
        }

        // Add cost if user is Administrator
        if matches!(role, UserRole::Administrator) {
            product["cost"] = json!(self.cost);
        }

        product
    }
}

/// User model with multi-provider authentication
/// In the real implementation, this would be:
/// #[derive(DeclarativeModel)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    /// User ID
    /// #[db(primary_key)]
    pub id: Uuid,

    /// Email address
    /// #[db(unique)]
    /// #[auth(identifier)]
    pub email: String,

    /// Display name
    pub name: String,

    /// User role
    /// #[permission(read = "Self", write = "Administrator")]
    pub role: UserRole,

    /// Authentication providers
    /// #[auth(providers = [Google, GitHub, Microsoft, LocalJWT])]
    pub auth_providers: Vec<AuthProvider>,

    /// Password hash (for LocalJWT only)
    #[serde(skip_serializing)]
    pub password_hash: Option<String>,
}

// ============================================================================
// APPLICATION STATE
// ============================================================================

#[derive(Clone)]
pub struct AppState {
    pub products: Arc<Vec<Product>>,
    pub users: Arc<Vec<User>>,
}

impl AppState {
    /// Initialize empty state
    /// Products will be added via API calls (see: task examples:rbac:seed)
    pub fn new() -> Self {
        Self { products: Arc::new(vec![]), users: Arc::new(vec![]) }
    }
}

// ============================================================================
// MAIN
// ============================================================================

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logger
    env_logger::init();

    // Parse CLI arguments
    let args = Args::parse();

    // Initialize application state
    let state = AppState::new();

    println!("üîê Lithair RBAC + SSO Demo");
    println!("============================");
    println!();
    println!("üì¶ Features Demonstrated:");
    println!("   ‚úÖ Declarative RBAC with field-level permissions");
    println!("   ‚úÖ Multi-provider SSO (Google, GitHub, Microsoft, JWT)");
    println!("   ‚úÖ Custom middleware (admin password, IP whitelist)");
    println!("   ‚úÖ Role-based data filtering");
    println!();
    println!("üë• Demo Users:");
    println!("   ‚Ä¢ customer@example.com (Customer role)");
    println!("   ‚Ä¢ manager@example.com  (ProductManager role)");
    println!("   ‚Ä¢ admin@example.com    (Administrator role)");
    println!();
    println!("üåê Server listening on http://{}:{}", args.host, args.port);
    println!();
    println!("üìö API Endpoints:");
    println!("   GET  /api/products              - List products (filtered by role)");
    println!("   GET  /api/products/{{id}}         - Get product by ID");
    println!("   POST /api/products              - Create product (Manager+)");
    println!("   DELETE /api/products/{{id}}       - Delete product (Admin only)");
    println!();
    println!("üîê Authentication:");
    println!("   GET  /auth/google/login         - Login with Google");
    println!("   GET  /auth/github/login         - Login with GitHub");
    println!("   GET  /auth/microsoft/login      - Login with Microsoft");
    println!("   POST /auth/jwt/login            - Login with email/password");
    println!();
    println!("üõ°Ô∏è  Admin (requires extra password):");
    println!("   GET  /admin/dashboard           - Admin dashboard");
    println!("   Header: X-Admin-Password: secret_admin_pass");
    println!();
    println!("üí° Try:");
    println!("   curl http://{}:{}/api/products", args.host, args.port);
    println!();
    println!("üìñ See README.md for complete documentation");
    println!();

    // In a real implementation, this would start the Hyper server
    // with all routes auto-generated from the declarative attributes

    // For this demo, we just show the data
    println!("üìä Demo Data:");
    println!();
    println!("Products ({} items):", state.products.len());
    for product in state.products.iter() {
        println!("  ‚Ä¢ {} - ${} (stock: {})", product.name, product.price, product.stock);
    }
    println!();
    println!("Users ({} items):", state.users.len());
    for user in state.users.iter() {
        println!("  ‚Ä¢ {} ({:?}) - Providers: {:?}", user.email, user.role, user.auth_providers);
    }
    println!();

    println!("‚úÖ Server ready!");
    println!("üìù Products will be added via API (see: task examples:rbac:seed)");
    println!();
    println!("üöÄ Starting DeclarativeServer with RBAC...");
    println!();
    println!("üí° To seed demo products, run in another terminal:");
    println!("   task examples:rbac:seed PORT={}", args.port);
    println!();

    // Start the Lithair DeclarativeServer with RBAC enabled
    // This will auto-generate all HTTP routes with RBAC middleware
    let event_store_path = "./data/rbac_products.events";

    // Configure RBAC with password provider
    let rbac_config = lithair_core::rbac::RbacConfig::new().enabled().with_provider(
        lithair_core::rbac::ProviderConfig::Password {
            password: "secret123".to_string(),
            default_role: "Customer".to_string(),
        },
    );

    DeclarativeServer::<Product>::new(event_store_path, args.port)?
        .with_rbac(rbac_config)
        .serve()
        .await
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_role_permissions() {
        // Customer can only read products
        assert!(UserRole::Customer.has_permission(ProductPermission::ProductRead));
        assert!(!UserRole::Customer.has_permission(ProductPermission::ProductWrite));
        assert!(!UserRole::Customer.has_permission(ProductPermission::StockRead));

        // ProductManager can read/write products and read stock
        assert!(UserRole::ProductManager.has_permission(ProductPermission::ProductRead));
        assert!(UserRole::ProductManager.has_permission(ProductPermission::ProductWrite));
        assert!(UserRole::ProductManager.has_permission(ProductPermission::StockRead));
        assert!(!UserRole::ProductManager.has_permission(ProductPermission::StockWrite));

        // Administrator has all permissions
        assert!(UserRole::Administrator.has_permission(ProductPermission::ProductRead));
        assert!(UserRole::Administrator.has_permission(ProductPermission::ProductWrite));
        assert!(UserRole::Administrator.has_permission(ProductPermission::ProductDelete));
        assert!(UserRole::Administrator.has_permission(ProductPermission::StockRead));
        assert!(UserRole::Administrator.has_permission(ProductPermission::StockWrite));
    }

    #[test]
    fn test_field_filtering() {
        let product = Product {
            id: Uuid::new_v4(),
            name: "Test Product".to_string(),
            description: "Test description".to_string(),
            price: 99.99,
            stock: 50,
            cost: 40.0,
        };

        // Customer should not see stock or cost
        let customer_view = product.filter_for_role(&UserRole::Customer);
        assert!(customer_view.get("id").is_some());
        assert!(customer_view.get("name").is_some());
        assert!(customer_view.get("price").is_some());
        assert!(customer_view.get("stock").is_none());
        assert!(customer_view.get("cost").is_none());

        // StockManager should see stock but not cost
        let manager_view = product.filter_for_role(&UserRole::StockManager);
        assert!(manager_view.get("stock").is_some());
        assert!(manager_view.get("cost").is_none());

        // Administrator should see everything
        let admin_view = product.filter_for_role(&UserRole::Administrator);
        assert!(admin_view.get("stock").is_some());
        assert!(admin_view.get("cost").is_some());
    }
}
